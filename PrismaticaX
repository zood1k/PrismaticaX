-- Load Fluent-Renewed library
local function LoadFluent()
    local success, result = pcall(function()
        return loadstring(game:HttpGet("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
    end)
    if not success or not result then
        error("Failed to load Fluent-Renewed library: " .. (result or "Unknown error"))
    end
    return result
end
local Fluent = LoadFluent()

-- Load addons
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()

-- Create main window
local Window = Fluent:CreateWindow({
    Title = "PrismaticaX 1.5",
    SubTitle = "By @zood3llotgk",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 450),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.Insert
})

-- Define tabs
local Tabs = {
    Visual = Window:AddTab({ Title = "Visual", Icon = "palette" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    Wallhack = Window:AddTab({ Title = "Wallhack", Icon = "eye" }),
    Combat = Window:AddTab({ Title = "Combat", Icon = "sword" }),
    Utilities = Window:AddTab({ Title = "Utilities", Icon = "wrench" }),
    Troll = Window:AddTab({ Title = "Troll", Icon = "smile" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

-- Services
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local plr = LocalPlayer
local Remotes = ReplicatedStorage:WaitForChild("Remotes")

-- Autofarm settings
local runningAutofarm = false
local runningUpgrade = false
local runningNextRagdoll = false
local runningRefine = false
local slamDuration = 20
local slamVelocity = 100

-- Freeze/unfreeze
local function SetFrozen(char, state)
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if hrp then hrp.Anchored = state end
end

-- Safe teleport character
local function SafeTeleport(char, cframeAbove)
    local parts = {}
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            parts[#parts+1] = part
            part.Anchored = true
            part.AssemblyLinearVelocity = Vector3.new()
            part.AssemblyAngularVelocity = Vector3.new()
        end
    end

    for _, part in pairs(parts) do
        part.CFrame = cframeAbove + Vector3.new(math.random(-1,1), 0, math.random(-1,1))
    end

    task.wait(0.3)

    for _, part in pairs(parts) do
        part.Anchored = false
    end
end

-- Fire ragdoll
local function FireRagdollTouch()
    local char = plr.Character
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local ragdollPart = workspace:FindFirstChild("RagdollParts") and workspace.RagdollParts:FindFirstChild("RagdollCollission")
    if hrp and ragdollPart then
        local touchInterest = ragdollPart:FindFirstChildOfClass("TouchTransmitter")
        if touchInterest then
            firetouchinterest(hrp, ragdollPart, 0)
            task.wait()
            firetouchinterest(hrp, ragdollPart, 1)
        end
    end
end

-- Autofarm loop
local function AutofarmLoop()
    while runningAutofarm do
        local char = plr.Character
        if not char then
            task.wait(1)
        else
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local head = char:FindFirstChild("Head")
            local spawnFolder = workspace:FindFirstChild("Spawn")
            if hrp and head and spawnFolder then
                local targetPart = workspace:GetChildren()[50]
                local teleportTarget = spawnFolder:GetChildren()[84]
                if targetPart and teleportTarget then
                    FireRagdollTouch()
                    local startTime = tick()
                    while tick()-startTime < slamDuration and runningAutofarm do
                        if not (hrp and head and targetPart) then break end
                        local direction = (targetPart.Position - hrp.Position).Unit
                        local velocity = direction * slamVelocity
                        for _, partName in pairs({"HumanoidRootPart","Head","Torso","Left Arm","Right Arm","Left Leg","Right Leg"}) do
                            local part = char:FindFirstChild(partName)
                            if part then
                                part.AssemblyLinearVelocity = velocity + Vector3.new(0,15,0)
                            end
                        end
                        task.wait(0.15)
                    end
                    SetFrozen(char,true)
                    SafeTeleport(char, teleportTarget.CFrame + Vector3.new(0,10,0))
                    SetFrozen(char,false)
                    local oldChar = char
                    repeat task.wait(0.5) until not runningAutofarm or (plr.Character ~= oldChar and plr.Character:FindFirstChild("HumanoidRootPart"))
                    if not runningAutofarm then return end
                    task.wait(1)
                    FireRagdollTouch()
                else
                    task.wait(1)
                end
            else
                task.wait(1)
            end
        end
    end
end

-- Auto upgrade
local function AutoUpgradeLoop()
    while runningUpgrade do
        Remotes.PurchaseBoneUpgrade:FireServer("Head")
        Remotes.PurchaseBoneUpgrade:FireServer("Torso")
        Remotes.PurchaseBoneUpgrade:FireServer("Arm")
        Remotes.PurchaseBoneUpgrade:FireServer("Leg")
        task.wait(0.2)
    end
end

-- Auto next ragdoll
local function AutoNextRagdollLoop()
    while runningNextRagdoll do
        Remotes.PurchaseNextRagdoll:FireServer()
        task.wait(0.5)
    end
end

-- Auto refine
local function AutoRefineLoop()
    while runningRefine do
        Remotes.RefineRagdoll:FireServer()
        task.wait(0.5)
    end
end

-- Centralized effect management for JumpEffect only
local EffectManager = {
    Effects = {},
    Connections = {},
    Objects = {},
    Active = {}
}

function EffectManager:RegisterEffect(name, enableFunc, disableFunc)
    self.Effects[name] = { Enable = enableFunc, Disable = disableFunc }
end

function EffectManager:EnableEffect(name)
    if self.Effects[name] and not self.Active[name] then
        pcall(function()
            self.Effects[name].Enable()
            self.Active[name] = true
        end)
    end
end

function EffectManager:DisableEffect(name)
    if self.Effects[name] and self.Active[name] then
        pcall(function()
            self.Effects[name].Disable()
            self.Active[name] = false
        end)
    end
end

function EffectManager:ClearVisual()
    for name, _ in pairs(self.Active) do
        self:DisableEffect(name)
    end
    for _, conn in pairs(self.Connections) do
        pcall(function() conn:Disconnect() end)
    end
    for _, obj in pairs(self.Objects) do
        pcall(function() obj:Destroy() end)
    end
    self.Connections = {}
    self.Objects = {}
    self.Active = {}
end

-- Rainbow color function
local function RainbowColor(time)
    local hue = (time * 0.3) % 1
    return Color3.fromHSV(hue, 1, 1)
end

-- Global rainbow update loop
local rainbow_updaters = {}
local rainbowConnection
local function StartRainbowLoop()
    if rainbowConnection then return end
    rainbowConnection = RunService.RenderStepped:Connect(function()
        local t = tick()
        for name, updater in pairs(rainbow_updaters) do
            pcall(updater, t)
        end
    end)
end

local function StopRainbowLoop()
    if rainbowConnection and next(rainbow_updaters) == nil then
        pcall(function() rainbowConnection:Disconnect() end)
        rainbowConnection = nil
    end
end

-- Rainbow UI Gradient
local uiGradientConnections = {}
task.spawn(function()
    task.wait(0.5)
    local CoreGui = game:GetService("CoreGui")
    local screenGui = CoreGui:FindFirstChild("Fluent")
    if not screenGui then return end

    local function ApplyGradient(obj)
        if not (obj:IsA("Frame") or obj:IsA("TextLabel") or obj:IsA("TextButton")) then return end
        obj.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        if not obj:FindFirstChild("UIGradient") then
            local gradient = Instance.new("UIGradient")
            gradient.Rotation = 45
            gradient.Parent = obj
            local conn
            conn = RunService.RenderStepped:Connect(function()
                if not obj or not obj.Parent or not gradient.Parent then
                    pcall(function() conn:Disconnect() end)
                    return
                end
                local t = tick() * 0.3
                local color1 = Color3.fromRGB(120 + math.sin(t*1.2)*20, 90 + math.sin(t)*15, 150 + math.sin(t*0.8)*20)
                local color2 = Color3.fromRGB(255, 180 + math.sin(t*0.5)*20, 200 + math.sin(t*0.7)*20)
                local color3 = Color3.fromRGB(10, 10, 20)
                gradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, color1),
                    ColorSequenceKeypoint.new(0.5, color2),
                    ColorSequenceKeypoint.new(1, color3)
                })
            end)
            table.insert(uiGradientConnections, conn)
        end
        if obj.BorderSizePixel and obj.BorderSizePixel > 0 then
            obj.BorderColor3 = Color3.fromRGB(255, 140, 180)
        end
    end

    for _, obj in pairs(screenGui:GetDescendants()) do
        ApplyGradient(obj)
    end

    local descendantConn = screenGui.DescendantAdded:Connect(ApplyGradient)
    table.insert(uiGradientConnections, descendantConn)
end)

-- Player variables
local OriginalWalkSpeed = 16
local OriginalJumpPower = 50
local OriginalJumpHeight = 7.2
local OriginalUseJumpPower = true
local CurrentWalkSpeed = 16
local CurrentJumpPower = 50
local InfiniteJumpEnabled = false
local NoclipEnabled = false
local FlyEnabled = false
local FlySpeed = 50
local flyBodyVelocity
local flyConnection
local noclipConnection
local speedConnection
local jumpConnection
local infiniteJumpConnection
local trails = {}
local trailsCharConn
local particleEmitter
local particlesCharConn
local chinaHat
local chinaHatConn
local starTrailEmitter
local neonGlowConn
local starTrailConn
local fireAuraConn
local smokeTrailConn
local sparkleBodyConn
local colorShiftConn
local aimbotEnabled = false
local aimbotFOV = 100
local aimbotConnection
local fovCircle
local fovConnection
local lockedTarget = nil
local aimbotActive = false
local aimbotBind = "MB2"
local aimbotMode = "Hold"
local SpinbotEnabled = false
local SpinbotSpeed = 10
local spinbotConnection
local TeamCheckEnabled = false
local WallCheckEnabled = false
local espTextSize = 25
local espColor = Color3.fromRGB(255, 255, 255)
local espRed = 255
local espGreen = 255
local espBlue = 255

-- Bind mappings
local bindMap = {
    MB1 = {Type = "UserInputType", Value = Enum.UserInputType.MouseButton1},
    MB2 = {Type = "UserInputType", Value = Enum.UserInputType.MouseButton2},
    MB3 = {Type = "UserInputType", Value = Enum.UserInputType.MouseButton3},
    Q = {Type = "KeyCode", Value = Enum.KeyCode.Q},
    E = {Type = "KeyCode", Value = Enum.KeyCode.E},
    R = {Type = "KeyCode", Value = Enum.KeyCode.R},
    T = {Type = "KeyCode", Value = Enum.KeyCode.T},
    Y = {Type = "KeyCode", Value = Enum.KeyCode.Y},
    U = {Type = "KeyCode", Value = Enum.KeyCode.U},
    I = {Type = "KeyCode", Value = Enum.KeyCode.I},
    O = {Type = "KeyCode", Value = Enum.KeyCode.O},
    P = {Type = "KeyCode", Value = Enum.KeyCode.P},
    F = {Type = "KeyCode", Value = Enum.KeyCode.F},
    G = {Type = "KeyCode", Value = Enum.KeyCode.G},
    H = {Type = "KeyCode", Value = Enum.KeyCode.H},
    J = {Type = "KeyCode", Value = Enum.KeyCode.J},
    K = {Type = "KeyCode", Value = Enum.KeyCode.K},
    L = {Type = "KeyCode", Value = Enum.KeyCode.L},
    Z = {Type = "KeyCode", Value = Enum.KeyCode.Z},
    X = {Type = "KeyCode", Value = Enum.KeyCode.X},
    C = {Type = "KeyCode", Value = Enum.KeyCode.C},
    V = {Type = "KeyCode", Value = Enum.KeyCode.V},
    B = {Type = "KeyCode", Value = Enum.KeyCode.B},
    N = {Type = "KeyCode", Value = Enum.KeyCode.N},
    M = {Type = "KeyCode", Value = Enum.KeyCode.M},
    One = {Type = "KeyCode", Value = Enum.KeyCode.One},
    Two = {Type = "KeyCode", Value = Enum.KeyCode.Two},
    Three = {Type = "KeyCode", Value = Enum.KeyCode.Three},
    Four = {Type = "KeyCode", Value = Enum.KeyCode.Four},
    Five = {Type = "KeyCode", Value = Enum.KeyCode.Five},
    LShift = {Type = "KeyCode", Value = Enum.KeyCode.LeftShift},
    RShift = {Type = "KeyCode", Value = Enum.KeyCode.RightShift},
    LCtrl = {Type = "KeyCode", Value = Enum.KeyCode.LeftControl},
    RCtrl = {Type = "KeyCode", Value = Enum.KeyCode.RightControl},
    LAlt = {Type = "KeyCode", Value = Enum.KeyCode.LeftAlt},
    RAlt = {Type = "KeyCode", Value = Enum.KeyCode.RightAlt}
}

-- Function to check if input matches bind
local function IsMatchingInput(input)
    local bindInfo = bindMap[aimbotBind]
    if not bindInfo then return false end
    if bindInfo.Type == "UserInputType" then
        return input.UserInputType == bindInfo.Value
    elseif bindInfo.Type == "KeyCode" then
        return input.KeyCode == bindInfo.Value
    end
    return false
end

-- Function to check if target is visible (Wall Check)
local function IsVisible(localRoot, targetHead)
    if not localRoot or not targetHead then return false end
    local ray = Ray.new(localRoot.Position, (targetHead.Position - localRoot.Position).Unit * 1000)
    local ignoreList = {LocalPlayer.Character}
    local hit, _ = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    return hit == nil or hit:IsDescendantOf(targetHead.Parent)
end

-- Function to update ESP color
local function UpdateESPColor()
    espColor = Color3.fromRGB(espRed, espGreen, espBlue)
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            if player.Character:FindFirstChild("ESPHighlight") then
                player.Character.ESPHighlight.FillColor = espColor
                player.Character.ESPHighlight.OutlineColor = espColor
            end
            if player.Character:FindFirstChild("Head") and player.Character.Head:FindFirstChild("NameTag") then
                player.Character.Head.NameTag.TagLabel.TextColor3 = espColor
            end
            if player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart:FindFirstChild("DistanceTag") then
                player.Character.HumanoidRootPart.DistanceTag.TagLabel.TextColor3 = espColor
            end
        end
    end
end

-- Capture original WalkSpeed and JumpPower
local function CaptureOriginals(char)
    local humanoid = char:WaitForChild("Humanoid", 10)
    if humanoid then
        OriginalWalkSpeed = humanoid.WalkSpeed
        OriginalJumpPower = humanoid.JumpPower
        OriginalJumpHeight = humanoid.JumpHeight
        OriginalUseJumpPower = humanoid.UseJumpPower
        CurrentWalkSpeed = math.max(CurrentWalkSpeed, OriginalWalkSpeed)
        CurrentJumpPower = math.max(CurrentJumpPower, OriginalJumpPower)
    end
end

if LocalPlayer.Character then
    CaptureOriginals(LocalPlayer.Character)
end

LocalPlayer.CharacterAdded:Connect(CaptureOriginals)

-- Jump Effect
EffectManager:RegisterEffect("Jump effect", function()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local humanoid = char:WaitForChild("Humanoid", 10)
    local root = char:WaitForChild("HumanoidRootPart", 10)
    if not humanoid or not root then return end

    local function CreateJumpEffect()
        local wave = Instance.new("Part")
        wave.Anchored = true
        wave.CanCollide = false
        wave.Size = Vector3.new(1, 0.2, 1)
        wave.Transparency = 0.5
        wave.Material = Enum.Material.Neon
        wave.Color = RainbowColor(tick())
        wave.Parent = workspace
        
        local mesh = Instance.new("CylinderMesh", wave)
        mesh.Scale = Vector3.new(0.1, 1, 0.1)
        
        local startPos = root.Position - Vector3.new(0, root.Size.Y/2 + 0.1, 0)
        wave.CFrame = CFrame.new(startPos) * CFrame.Angles(math.rad(90), 0, 0)
        
        local startTime = tick()
        local waveConn = RunService.RenderStepped:Connect(function()
            local t = tick() - startTime
            mesh.Scale = Vector3.new(2 + t * 8, 0.05, 2 + t * 8)
            wave.Transparency = math.clamp(0.3 + t*2, 0, 1)
            
            if t > 1 then
                waveConn:Disconnect()
                wave:Destroy()
            end
        end)
        table.insert(EffectManager.Connections, waveConn)
    end

    local conn = humanoid.Jumping:Connect(CreateJumpEffect)
    table.insert(EffectManager.Connections, conn)
    
    if humanoid:GetState() == Enum.HumanoidStateType.Jumping then
        CreateJumpEffect()
    end
end, function()
    for _, conn in pairs(EffectManager.Connections) do
        pcall(function() conn:Disconnect() end)
    end
    EffectManager.Connections = {}
end)

-- Visual Effects Module
local VisualEffects = {}

function VisualEffects:FireAura()
    self:ClearEffectByName("FireAura")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart", 10)
    if not root then return end
    
    local fire = Instance.new("Fire")
    fire.Name = "FireAura"
    fire.Size = 8
    fire.Heat = 5
    fire.Color = Color3.fromRGB(255, 100, 0)
    fire.SecondaryColor = Color3.fromRGB(255, 255, 0)
    fire.Parent = root
end

function VisualEffects:SmokeTrail()
    self:ClearEffectByName("SmokeTrail")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart", 10)
    if not root then return end
    
    local smoke = Instance.new("Smoke")
    smoke.Name = "SmokeTrail"
    smoke.Size = 2
    smoke.Color = Color3.fromRGB(200, 200, 200)
    smoke.RiseVelocity = 2
    smoke.Opacity = 0.3
    smoke.Parent = root
end

function VisualEffects:SparkleBody()
    self:ClearEffectByName("BodySparkles")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart", 10)
    if not root then return end
    
    local sparkles = Instance.new("Sparkles")
    sparkles.Name = "BodySparkles"
    sparkles.SparkleColor = Color3.fromRGB(255, 255, 0)
    sparkles.Parent = root
end

function VisualEffects:ColorShift()
    self:ClearEffectByName("ColorShift")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if not char then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "ColorShift"
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0.3
    highlight.Parent = char
    
    task.spawn(function()
        while highlight and highlight.Parent do
            for hue = 0, 1, 0.05 do
                if not highlight or not highlight.Parent then break end
                local color = Color3.fromHSV(hue, 1, 1)
                highlight.FillColor = color
                highlight.OutlineColor = color
                task.wait(0.2)
            end
        end
    end)
end

function VisualEffects:NeonGlow()
    self:ClearEffectByName("NeonGlow")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if not char then return end
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "NeonGlow"
    highlight.Adornee = char
    highlight.FillTransparency = 0.9
    highlight.OutlineTransparency = 0
    highlight.OutlineColor = RainbowColor(tick())
    highlight.Parent = char
    
    rainbow_updaters["NeonGlow"] = function(t)
        if highlight and highlight.Parent then
            highlight.OutlineColor = RainbowColor(t)
        end
    end
    StartRainbowLoop()
end

function VisualEffects:StarTrail()
    self:ClearEffectByName("StarTrail")
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart", 10)
    if not root then return end
    
    starTrailEmitter = Instance.new("ParticleEmitter")
    starTrailEmitter.Name = "StarTrail"
    starTrailEmitter.Parent = root
    starTrailEmitter.Size = NumberSequence.new(0.3)
    starTrailEmitter.Transparency = NumberSequence.new(0.2)
    starTrailEmitter.Lifetime = NumberRange.new(1)
    starTrailEmitter.Rate = 10
    starTrailEmitter.Speed = NumberRange.new(5)
    starTrailEmitter.VelocitySpread = 180
    starTrailEmitter.Rotation = NumberRange.new(0, 360)
    starTrailEmitter.Texture = "rbxassetid://243660364"
    starTrailEmitter.Color = ColorSequence.new(RainbowColor(tick()))
    starTrailEmitter.Enabled = true
    
    rainbow_updaters["StarTrail"] = function(t)
        if starTrailEmitter and starTrailEmitter.Parent then
            starTrailEmitter.Color = ColorSequence.new(RainbowColor(t))
        end
    end
    StartRainbowLoop()
end

function VisualEffects:ClearEffectByName(name)
    local char = LocalPlayer.Character
    if char then
        for _, effect in pairs(char:GetDescendants()) do
            if effect.Name == name then
                pcall(function() effect:Destroy() end)
            end
        end
    end
end

-- Highlight ESP Module
local HighlightESP = {}
local highlightESPConnection
local highlightESPCharacterConns = {}

function HighlightESP:CreateHighlight(player)
    local character = player.Character
    if character then
        local highlight = character:FindFirstChild("ESPHighlight")
        if not highlight then
            highlight = Instance.new("Highlight")
            highlight.Name = "ESPHighlight"
            highlight.FillColor = espColor
            highlight.OutlineColor = espColor
            highlight.FillTransparency = 0.6
            highlight.OutlineTransparency = 0
            highlight.Adornee = character
            highlight.Parent = character
        end
    end
end

function HighlightESP:EnableESP()
    if highlightESPConnection then return end

    local function SetupHighlight(player)
        if player ~= LocalPlayer then
            local charConn = player.CharacterAdded:Connect(function(character)
                task.wait(0.5)
                HighlightESP:CreateHighlight(player)
            end)
            table.insert(highlightESPCharacterConns, charConn)
            if player.Character then
                HighlightESP:CreateHighlight(player)
            end
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        SetupHighlight(player)
    end

    highlightESPConnection = Players.PlayerAdded:Connect(SetupHighlight)
end

function HighlightESP:DisableESP()
    if highlightESPConnection then
        pcall(function() highlightESPConnection:Disconnect() end)
        highlightESPConnection = nil
    end
    for _, conn in pairs(highlightESPCharacterConns) do
        pcall(function() conn:Disconnect() end)
    end
    highlightESPCharacterConns = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            local highlight = player.Character:FindFirstChild("ESPHighlight")
            if highlight then
                pcall(function() highlight:Destroy() end)
            end
        end
    end
end

-- Name ESP Module
local NameESP = {}
local nameESPConnection
local nameESPCharacterConns = {}

function NameESP:CreateNameTag(player)
    local character = player.Character
    if character then
        local head = character:WaitForChild("Head", 10)
        if head then
            local billboard = head:FindFirstChild("NameTag")
            if not billboard then
                billboard = Instance.new("BillboardGui")
                billboard.Name = "NameTag"
                billboard.Adornee = head
                billboard.Size = UDim2.new(0, 130, 0, espTextSize)
                billboard.StudsOffset = Vector3.new(0, 2, 0)
                billboard.AlwaysOnTop = true
                billboard.Parent = head

                local textLabel = Instance.new("TextLabel")
                textLabel.Name = "TagLabel"
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextColor3 = espColor
                textLabel.Font = Enum.Font.Cartoon
                textLabel.TextScaled = true
                textLabel.TextStrokeTransparency = 0.6
                textLabel.Text = player.Name
                textLabel.Parent = billboard
            end
        end
    end
end

function NameESP:EnableESP()
    if nameESPConnection then return end

    local function SetupName(player)
        if player ~= LocalPlayer then
            local charConn = player.CharacterAdded:Connect(function(character)
                task.wait(0.5)
                NameESP:CreateNameTag(player)
            end)
            table.insert(nameESPCharacterConns, charConn)
            if player.Character then
                NameESP:CreateNameTag(player)
            end
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        SetupName(player)
    end

    nameESPConnection = Players.PlayerAdded:Connect(SetupName)
end

function NameESP:DisableESP()
    if nameESPConnection then
        pcall(function() nameESPConnection:Disconnect() end)
        nameESPConnection = nil
    end
    for _, conn in pairs(nameESPCharacterConns) do
        pcall(function() conn:Disconnect() end)
    end
    nameESPCharacterConns = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("Head") then
            local nameTag = player.Character.Head:FindFirstChild("NameTag")
            if nameTag then
                pcall(function() nameTag:Destroy() end)
            end
        end
    end
end

-- Distance ESP Module
local DistanceESP = {}
local distanceESPConnection
local distanceESPCharacterConns = {}
local distanceUpdateConn

function DistanceESP:CreateDistanceTag(player)
    local character = player.Character
    if character then
        local root = character:WaitForChild("HumanoidRootPart", 10)
        if root then
            local billboard = root:FindFirstChild("DistanceTag")
            if not billboard then
                billboard = Instance.new("BillboardGui")
                billboard.Name = "DistanceTag"
                billboard.Adornee = root
                billboard.Size = UDim2.new(0, 130, 0, espTextSize)
                billboard.StudsOffset = Vector3.new(0, -3.5, 0)
                billboard.AlwaysOnTop = true
                billboard.Parent = root

                local textLabel = Instance.new("TextLabel")
                textLabel.Name = "TagLabel"
                textLabel.Size = UDim2.new(1, 0, 1, 0)
                textLabel.BackgroundTransparency = 1
                textLabel.TextColor3 = espColor
                textLabel.Font = Enum.Font.Cartoon
                textLabel.TextScaled = true
                textLabel.TextStrokeTransparency = 0.6
                textLabel.Text = ""
                textLabel.Parent = billboard
            end
        end
    end
end

function DistanceESP:UpdateDistanceTag(player)
    if player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart:FindFirstChild("DistanceTag") then
        local tag = player.Character.HumanoidRootPart.DistanceTag.TagLabel
        local distance = (LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and player.Character.PrimaryPart and (LocalPlayer.Character.PrimaryPart.Position - player.Character.PrimaryPart.Position).Magnitude) or 0
        tag.Text = string.format("%.0f", distance) .. "m"
    end
end

function DistanceESP:EnableESP()
    if distanceESPConnection then return end

    local function SetupDistance(player)
        if player ~= LocalPlayer then
            local charConn = player.CharacterAdded:Connect(function(character)
                task.wait(0.5)
                DistanceESP:CreateDistanceTag(player)
            end)
            table.insert(distanceESPCharacterConns, charConn)
            if player.Character then
                DistanceESP:CreateDistanceTag(player)
            end
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        SetupDistance(player)
    end

    distanceESPConnection = Players.PlayerAdded:Connect(SetupDistance)

    distanceUpdateConn = RunService.Heartbeat:Connect(function()
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer then
                DistanceESP:UpdateDistanceTag(player)
            end
        end
    end)
end

function DistanceESP:DisableESP()
    if distanceESPConnection then
        pcall(function() distanceESPConnection:Disconnect() end)
        distanceESPConnection = nil
    end
    for _, conn in pairs(distanceESPCharacterConns) do
        pcall(function() conn:Disconnect() end)
    end
    distanceESPCharacterConns = {}
    if distanceUpdateConn then
        pcall(function() distanceUpdateConn:Disconnect() end)
        distanceUpdateConn = nil
    end
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local distanceTag = player.Character.HumanoidRootPart:FindFirstChild("DistanceTag")
            if distanceTag then
                pcall(function() distanceTag:Destroy() end)
            end
        end
    end
end

-- Aimbot Module
local Aimbot = {}

function Aimbot:ShowFOV()
    if fovCircle then
        pcall(function() fovCircle:Destroy() end)
    end
    fovCircle = Instance.new("BillboardGui")
    fovCircle.Name = "AimbotFOV"
    fovCircle.Size = UDim2.new(0, aimbotFOV * 2, 0, aimbotFOV * 2)
    fovCircle.Adornee = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    fovCircle.StudsOffset = Vector3.new(0, 0, -aimbotFOV)
    fovCircle.AlwaysOnTop = true
    fovCircle.Parent = Workspace
    
    local circle = Instance.new("Frame")
    circle.Size = UDim2.new(1, 0, 1, 0)
    circle.BackgroundTransparency = 1
    circle.BorderSizePixel = 0
    circle.Parent = fovCircle
    
    local uiStroke = Instance.new("UIStroke")
    uiStroke.Color = Color3.fromRGB(255, 0, 0)
    uiStroke.Thickness = 2
    uiStroke.Transparency = 0.5
    uiStroke.Parent = circle
    
    local uiCorner = Instance.new("UICorner")
    uiCorner.CornerRadius = UDim.new(1, 0)
    uiCorner.Parent = circle
    
    if not fovConnection then
        fovConnection = RunService.RenderStepped:Connect(function()
            local localChar = LocalPlayer.Character
            if not localChar then
                Aimbot:HideFOV()
                return
            end
            local localRoot = localChar:FindFirstChild("HumanoidRootPart")
            if not localRoot then
                Aimbot:HideFOV()
                return
            end
            if fovCircle and fovCircle.Parent and aimbotEnabled then
                fovCircle.Size = UDim2.new(0, aimbotFOV * 2, 0, aimbotFOV * 2)
                fovCircle.Adornee = localRoot
                fovCircle.StudsOffset = Vector3.new(0, 0, -aimbotFOV)
            else
                Aimbot:HideFOV()
            end
        end)
    end
end

function Aimbot:HideFOV()
    if fovCircle then
        pcall(function() fovCircle:Destroy() end)
        fovCircle = nil
    end
    if fovConnection then
        pcall(function() fovConnection:Disconnect() end)
        fovConnection = nil
    end
end

function Aimbot:Enable()
    if aimbotConnection then return end
    
    aimbotConnection = RunService.RenderStepped:Connect(function()
        if not aimbotActive then
            if aimbotConnection then
                aimbotConnection:Disconnect()
                aimbotConnection = nil
            end
            return
        end
        
        local localChar = LocalPlayer.Character
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end
        
        local camera = Workspace.CurrentCamera
        
        if lockedTarget and (not lockedTarget.Parent or not lockedTarget.Character) then
            lockedTarget = nil
        end
        
        if lockedTarget and lockedTarget.Character then
            local targetHead = lockedTarget.Character:FindFirstChild("Head")
            if targetHead and (WallCheckEnabled or IsVisible(localRoot, targetHead)) then
                camera.CFrame = CFrame.new(camera.CFrame.Position, targetHead.Position)
            else
                lockedTarget = nil
            end
        end
        
        if not lockedTarget then
            local closestPlayer = nil
            local smallestAngle = math.rad(aimbotFOV / 2)
            
            for _, plr in pairs(Players:GetPlayers()) do
                if plr ~= LocalPlayer and (not TeamCheckEnabled or not (plr.Team and LocalPlayer.Team and plr.Team == LocalPlayer.Team)) then
                    local char = plr.Character
                    local root = char and char:FindFirstChild("HumanoidRootPart")
                    local head = char and char:FindFirstChild("Head")
                    if root and head then
                        local distance = (localRoot.Position - root.Position).Magnitude
                        if distance <= aimbotFOV then
                            local screenPoint, onScreen = camera:WorldToScreenPoint(head.Position)
                            if onScreen and (WallCheckEnabled or IsVisible(localRoot, head)) then
                                local directionToTarget = (head.Position - camera.CFrame.Position).Unit
                                local cameraDirection = camera.CFrame.LookVector
                                local angle = math.acos(directionToTarget:Dot(cameraDirection))
                                if angle <= smallestAngle then
                                    smallestAngle = angle
                                    closestPlayer = plr
                                end
                            end
                        end
                    end
                end
            end
            
            lockedTarget = closestPlayer
        end
    end)
end

function Aimbot:Disable()
    if aimbotConnection then
        pcall(function() aimbotConnection:Disconnect() end)
        aimbotConnection = nil
    end
    lockedTarget = nil
end

-- Spinbot Module
local Spinbot = {}

function Spinbot:Enable()
    if spinbotConnection then return end
    
    spinbotConnection = RunService.RenderStepped:Connect(function()
        if not SpinbotEnabled then
            if spinbotConnection then
                spinbotConnection:Disconnect()
                spinbotConnection = nil
            end
            return
        end
        
        local char = LocalPlayer.Character
        if not char then return end
        local root = char:FindFirstChild("HumanoidRootPart")
        if not root then return end
        
        root.CFrame = root.CFrame * CFrame.Angles(0, math.rad(SpinbotSpeed * 10), 0)
    end)
end

function Spinbot:Disable()
    if spinbotConnection then
        pcall(function() spinbotConnection:Disconnect() end)
        spinbotConnection = nil
    end
end

-- WallCheck Module
local WallCheck = {}

function WallCheck:Enable()
    if wallCheckConnection then return end
    
    wallCheckConnection = RunService.RenderStepped:Connect(function()
        if not WallCheckEnabled then
            if wallCheckConnection then
                wallCheckConnection:Disconnect()
                wallCheckConnection = nil
            end
            return
        end
        
        local localChar = LocalPlayer.Character
        if not localChar then return end
        local localRoot = localChar:FindFirstChild("HumanoidRootPart")
        if not localRoot then return end
        
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer then
                local char = plr.Character
                local head = char and char:FindFirstChild("Head")
                if head then
                    local highlight = char:FindFirstChild("WallCheckHighlight")
                    if IsVisible(localRoot, head) then
                        if not highlight then
                            highlight = Instance.new("Highlight")
                            highlight.Name = "WallCheckHighlight"
                            highlight.Adornee = char
                            highlight.FillColor = Color3.fromRGB(255, 0, 0)
                            highlight.FillTransparency = 0.7
                            highlight.OutlineColor = Color3.fromRGB(255, 0, 0)
                            highlight.OutlineTransparency = 0
                            highlight.Parent = char
                        end
                    else
                        if highlight then
                            pcall(function() highlight:Destroy() end)
                        end
                    end
                end
            end
        end
    end)
end

function WallCheck:Disable()
    if wallCheckConnection then
        pcall(function() wallCheckConnection:Disconnect() end)
        wallCheckConnection = nil
    end
    for _, plr in pairs(Players:GetPlayers()) do
        local char = plr.Character
        if char then
            local highlight = char:FindFirstChild("WallCheckHighlight")
            if highlight then
                pcall(function() highlight:Destroy() end)
            end
        end
    end
end

-- Cleanup function
local function CleanupAll()
    runningAutofarm = false
    runningUpgrade = false
    runningNextRagdoll = false
    runningRefine = false
    
    EffectManager:ClearVisual()
    VisualEffects:ClearEffectByName("FireAura")
    VisualEffects:ClearEffectByName("SmokeTrail")
    VisualEffects:ClearEffectByName("BodySparkles")
    VisualEffects:ClearEffectByName("ColorShift")
    VisualEffects:ClearEffectByName("NeonGlow")
    VisualEffects:ClearEffectByName("StarTrail")
    
    for name, toggle in pairs(toggles) do
        toggle:SetValue(false)
    end

    if speedConnection then
        pcall(function() speedConnection:Disconnect() end)
        speedConnection = nil
    end
    if jumpConnection then
        pcall(function() jumpConnection:Disconnect() end)
        jumpConnection = nil
    end
    if infiniteJumpConnection then
        pcall(function() infiniteJumpConnection:Disconnect() end)
        infiniteJumpConnection = nil
    end
    if noclipConnection then
        pcall(function() noclipConnection:Disconnect() end)
        noclipConnection = nil
    end
    if flyConnection then
        pcall(function() flyConnection:Disconnect() end)
        flyConnection = nil
    end
    if flyBodyVelocity then
        pcall(function() flyBodyVelocity:Destroy() end)
        flyBodyVelocity = nil
    end
    if trailsCharConn then
        pcall(function() trailsCharConn:Disconnect() end)
        trailsCharConn = nil
    end
    if particlesCharConn then
        pcall(function() particlesCharConn:Disconnect() end)
        particlesCharConn = nil
    end
    if chinaHatConn then
        pcall(function() chinaHatConn:Disconnect() end)
        chinaHatConn = nil
    end
    if neonGlowConn then
        pcall(function() neonGlowConn:Disconnect() end)
        neonGlowConn = nil
    end
    if starTrailConn then
        pcall(function() starTrailConn:Disconnect() end)
        starTrailConn = nil
    end
    if fireAuraConn then
        pcall(function() fireAuraConn:Disconnect() end)
        fireAuraConn = nil
    end
    if smokeTrailConn then
        pcall(function() smokeTrailConn:Disconnect() end)
        smokeTrailConn = nil
    end
    if sparkleBodyConn then
        pcall(function() sparkleBodyConn:Disconnect() end)
        sparkleBodyConn = nil
    end
    if colorShiftConn then
        pcall(function() colorShiftConn:Disconnect() end)
        colorShiftConn = nil
    end
    if rainbowConnection then
        pcall(function() rainbowConnection:Disconnect() end)
        rainbowConnection = nil
    end
    if spinbotConnection then
        pcall(function() spinbotConnection:Disconnect() end)
        spinbotConnection = nil
    end
    if wallCheckConnection then
        pcall(function() wallCheckConnection:Disconnect() end)
        wallCheckConnection = nil
    end
    for _, conn in pairs(uiGradientConnections) do
        pcall(function() conn:Disconnect() end)
    end
    uiGradientConnections = {}

    if chinaHat then
        pcall(function() chinaHat:Destroy() end)
        chinaHat = nil
    end
    if particleEmitter then
        pcall(function() particleEmitter:Destroy() end)
        particleEmitter = nil
    end
    if starTrailEmitter then
        pcall(function() starTrailEmitter:Destroy() end)
        starTrailEmitter = nil
    end
    trails = {}
    rainbow_updaters = {}
    
    HighlightESP:DisableESP()
    NameESP:DisableESP()
    DistanceESP:DisableESP()
    
    Aimbot:Disable()
    Aimbot:HideFOV()
    Spinbot:Disable()
    WallCheck:Disable()
    
    local char = LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = OriginalWalkSpeed
            humanoid.UseJumpPower = OriginalUseJumpPower
            if humanoid.UseJumpPower then
                humanoid.JumpPower = OriginalJumpPower
            else
                humanoid.JumpHeight = OriginalJumpHeight
            end
        end
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
            if part.Name == "FireAura" or part.Name == "SmokeTrail" or part.Name == "BodySparkles" or part.Name == "ColorShift" or part.Name == "RainbowTrail" or part.Name == "TrailAttachment0" or part.Name == "TrailAttachment1" or part.Name == "NeonGlow" or part.Name == "StarTrail" or part.Name == "WallCheckHighlight" then
                pcall(function() part:Destroy() end)
            end
        end
    end
    
    InfiniteJumpEnabled = false
    NoclipEnabled = false
    FlyEnabled = false
    aimbotEnabled = false
    aimbotActive = false
    lockedTarget = nil
    SpinbotEnabled = false
    TeamCheckEnabled = false
    WallCheckEnabled = false
    espTextSize = 25
    espColor = Color3.fromRGB(255, 255, 255)
    espRed = 255
    espGreen = 255
    espBlue = 255
end

-- UI Setup
local VisualSection = Tabs.Visual:AddSection("Visual")
local ClearSection = Tabs.Visual:AddSection("Clear")
local PlayerSection = Tabs.Player:AddSection("Player")
local PlayerESPSection = Tabs.Wallhack:AddSection("Player ESP")
local SizeSection = Tabs.Wallhack:AddSection("Size")
local SettingsColorESPSection = Tabs.Wallhack:AddSection("Settings color ESP")
local CombatSection = Tabs.Combat:AddSection("Combat")
local TrollSection = Tabs.Troll:AddSection("Troll")

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes{}

InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/PrismaticaX")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Troll GUI button
TrollSection:AddButton({
    Title = "Troll GUI",
    Description = "Load Troll GUI script",
    Callback = function()
        pcall(function()
            loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Fling-Gui-Op-47914"))()
        end)
    end
})

-- Combat toggles, sliders, and dropdowns
local toggles = {}
toggles.Aimbot = CombatSection:AddToggle("Aimbot", {Title = "Aimbot", Default = false})
toggles.Aimbot:OnChanged(function(val)
    aimbotEnabled = val
    if val then
        Aimbot:ShowFOV()
        if aimbotMode == "Toggle" and aimbotActive then
            Aimbot:Enable()
        end
    else
        Aimbot:Disable()
        Aimbot:HideFOV()
        aimbotActive = false
    end
end)

CombatSection:AddDropdown("AimbotBind", {
    Title = "Aimbot bind",
    Description = "Select bind for aimbot",
    Values = {
        "MB1", "MB2", "MB3", "Q", "E", "R", "T", "Y", "U", "I", "O", "P",
        "F", "G", "H", "J", "K", "L", "Z", "X", "C", "V", "B", "N", "M",
        "One", "Two", "Three", "Four", "Five", "LShift", "RShift", "LCtrl",
        "RCtrl", "LAlt", "RAlt"
    },
    Default = "MB2",
    Callback = function(val)
        aimbotBind = val
    end
})

CombatSection:AddDropdown("AimbotMode", {
    Title = "Aimbot mode",
    Description = "Select aimbot mode",
    Values = {"Hold", "Toggle"},
    Default = "Hold",
    Callback = function(val)
        aimbotMode = val
        if aimbotMode == "Hold" then
            aimbotActive = false
            Aimbot:Disable()
            lockedTarget = nil
        end
    end
})

CombatSection:AddSlider("AimbotFOV", {
    Title = "Aimbot FOV",
    Description = "Set aimbot FOV (10-800)",
    Default = 100,
    Min = 10,
    Max = 800,
    Rounding = 0,
    Callback = function(val)
        aimbotFOV = val
        if fovCircle and fovCircle.Parent then
            fovCircle.Size = UDim2.new(0, aimbotFOV * 2, 0, aimbotFOV * 2)
        end
    end
})

toggles.Spinbot = CombatSection:AddToggle("Spinbot", {Title = "Spinbot", Default = false})
toggles.Spinbot:OnChanged(function(val)
    SpinbotEnabled = val
    if val then
        Spinbot:Enable()
    else
        Spinbot:Disable()
    end
end)

CombatSection:AddSlider("SpinbotSpeed", {
    Title = "Spinbot speed",
    Description = "Set spinbot speed (1-30)",
    Default = 10,
    Min = 1,
    Max = 30,
    Rounding = 0,
    Callback = function(val)
        SpinbotSpeed = val
    end
})

toggles.TeamCheck = CombatSection:AddToggle("TeamCheck", {Title = "Team check", Default = false})
toggles.TeamCheck:OnChanged(function(val)
    TeamCheckEnabled = val
end)

toggles.WallCheck = CombatSection:AddToggle("WallCheck", {Title = "Wall check", Default = false})
toggles.WallCheck:OnChanged(function(val)
    WallCheckEnabled = val
    if val then
        WallCheck:Enable()
    else
        WallCheck:Disable()
    end
end)

-- Aimbot bind handlers
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if gameProcessedEvent then return end
    if IsMatchingInput(input) and aimbotEnabled then
        if aimbotMode == "Hold" then
            aimbotActive = true
            lockedTarget = nil
            Aimbot:Enable()
        elseif aimbotMode == "Toggle" then
            aimbotActive = not aimbotActive
            if aimbotActive then
                lockedTarget = nil
                Aimbot:Enable()
            else
                Aimbot:Disable()
            end
        end
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if aimbotMode == "Hold" and IsMatchingInput(input) and aimbotEnabled then
        aimbotActive = false
        Aimbot:Disable()
        lockedTarget = nil
    end
end)

-- Wallhack toggles
toggles.HighlightESP = PlayerESPSection:AddToggle("HighlightESP", {Title = "Highlight ESP", Default = false})
toggles.HighlightESP:OnChanged(function(val)
    if val then
        HighlightESP:EnableESP()
    else
        HighlightESP:DisableESP()
    end
end)

toggles.NameESP = PlayerESPSection:AddToggle("NameESP", {Title = "Name ESP", Default = false})
toggles.NameESP:OnChanged(function(val)
    if val then
        NameESP:EnableESP()
    else
        NameESP:DisableESP()
    end
end)

toggles.DistanceESP = PlayerESPSection:AddToggle("DistanceESP", {Title = "Distance ESP", Default = false})
toggles.DistanceESP:OnChanged(function(val)
    if val then
        DistanceESP:EnableESP()
    else
        DistanceESP:DisableESP()
    end
end)

-- Size ESP
SizeSection:AddSlider("SizeESP", {
    Title = "Size ESP",
    Description = "Set ESP text size (10-50)",
    Default = 25,
    Min = 10,
    Max = 50,
    Rounding = 0,
    Callback = function(val)
        espTextSize = val
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                if player.Character:FindFirstChild("Head") and player.Character.Head:FindFirstChild("NameTag") then
                    player.Character.Head.NameTag.Size = UDim2.new(0, 130, 0, espTextSize)
                end
                if player.Character:FindFirstChild("HumanoidRootPart") and player.Character.HumanoidRootPart:FindFirstChild("DistanceTag") then
                    player.Character.HumanoidRootPart.DistanceTag.Size = UDim2.new(0, 130, 0, espTextSize)
                end
            end
        end
    end
})

-- Settings color ESP
SettingsColorESPSection:AddSlider("RedESP", {
    Title = "Red ESP",
    Description = "Set red color component (0-255)",
    Default = 255,
    Min = 0,
    Max = 255,
    Rounding = 0,
    Callback = function(val)
        espRed = val
        UpdateESPColor()
    end
})

SettingsColorESPSection:AddSlider("GreenESP", {
    Title = "Green ESP",
    Description = "Set green color component (0-255)",
    Default = 255,
    Min = 0,
    Max = 255,
    Rounding = 0,
    Callback = function(val)
        espGreen = val
        UpdateESPColor()
    end
})

SettingsColorESPSection:AddSlider("BlueESP", {
    Title = "Blue ESP",
    Description = "Set blue color component (0-255)",
    Default = 255,
    Min = 0,
    Max = 255,
    Rounding = 0,
    Callback = function(val)
        espBlue = val
        UpdateESPColor()
    end
})

-- Visual effects toggles
toggles.ChinaHat = VisualSection:AddToggle("ChinaHat", {Title = "China hat", Default = false})
toggles.ChinaHat:OnChanged(function(val)
    if val then
        local function AddChinaHat(char)
            local head = char:WaitForChild("Head", 10)
            if not head then return end
            if chinaHat then
                pcall(function() chinaHat:Destroy() end)
            end
            chinaHat = Instance.new("Part")
            chinaHat.Name = "ChinaHat"
            chinaHat.Size = Vector3.new(3, 0.3, 3)
            chinaHat.Anchored = true
            chinaHat.CanCollide = false
            chinaHat.Transparency = 0.3
            chinaHat.Material = Enum.Material.Neon
            chinaHat.Color = RainbowColor(tick())
            chinaHat.Parent = workspace
            
            local mesh = Instance.new("SpecialMesh", chinaHat)
            mesh.MeshType = Enum.MeshType.FileMesh
            mesh.MeshId = "rbxassetid://1033714"
            mesh.Scale = Vector3.new(2, 0.5, 2)
            
            local updateConn
            updateConn = RunService.RenderStepped:Connect(function()
                if not toggles.ChinaHat.Value or not chinaHat or not chinaHat.Parent or not head or not head.Parent then
                    if updateConn then
                        updateConn:Disconnect()
                    end
                    if chinaHat then
                        pcall(function() chinaHat:Destroy() end)
                        chinaHat = nil
                    end
                    rainbow_updaters["ChinaHat"] = nil
                    StopRainbowLoop()
                    return
                end
                chinaHat.Color = RainbowColor(tick())
                chinaHat.CFrame = head.CFrame * CFrame.new(0, 1, 0) * CFrame.Angles(0, math.rad(tick() * 20), 0)
            end)
            
            rainbow_updaters["ChinaHat"] = function(t)
                if chinaHat and chinaHat.Parent then
                    chinaHat.Color = RainbowColor(t)
                end
            end
            StartRainbowLoop()
        end
        
        local char = LocalPlayer.Character
        if char then
            AddChinaHat(char)
        end
        
        if not chinaHatConn then
            chinaHatConn = LocalPlayer.CharacterAdded:Connect(function(newChar)
                if toggles.ChinaHat.Value then
                    task.wait(1)
                    AddChinaHat(newChar)
                end
            end)
        end
    else
        if chinaHatConn then
            chinaHatConn:Disconnect()
            chinaHatConn = nil
        end
        if chinaHat then
            pcall(function() chinaHat:Destroy() end)
            chinaHat = nil
        end
        rainbow_updaters["ChinaHat"] = nil
        StopRainbowLoop()
    end
end)

toggles.Trails = VisualSection:AddToggle("Trails", {Title = "Rainbow trails", Default = false})
toggles.Trails:OnChanged(function(val)
    if val then
        local function AddTrails(char)
            trails = {}
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") and (part.Name:match("Hand") or part.Name:match("Arm")) then
                    for _, child in pairs(part:GetChildren()) do
                        if child:IsA("Attachment") and (child.Name == "TrailAttachment0" or child.Name == "TrailAttachment1") or child:IsA("Trail") then
                            pcall(function() child:Destroy() end)
                        end
                    end
                    
                    local att0 = Instance.new("Attachment", part)
                    att0.Name = "TrailAttachment0"
                    local att1 = Instance.new("Attachment", part)
                    att1.Name = "TrailAttachment1"
                    att1.Position = Vector3.new(0, -0.5, 0)
                    
                    local trail = Instance.new("Trail")
                    trail.Name = "RainbowTrail"
                    trail.Attachment0 = att0
                    trail.Attachment1 = att1
                    trail.Lifetime = 0.5
                    trail.WidthScale = NumberSequence.new(0.5)
                    trail.Transparency = NumberSequence.new(0)
                    trail.Color = ColorSequence.new({
                        ColorSequenceKeypoint.new(0, RainbowColor(tick())),
                        ColorSequenceKeypoint.new(0.5, RainbowColor(tick() + 2*math.pi/3)),
                        ColorSequenceKeypoint.new(1, RainbowColor(tick() + 4*math.pi/3))
                    })
                    trail.Parent = part
                    
                    table.insert(trails, trail)
                end
            end
        end
        
        local char = LocalPlayer.Character
        if char then
            AddTrails(char)
        end
        
        if not trailsCharConn then
            trailsCharConn = LocalPlayer.CharacterAdded:Connect(function(newChar)
                if toggles.Trails.Value then
                    task.wait(1)
                    AddTrails(newChar)
                end
            end)
        end
        
        rainbow_updaters["Trails"] = function(t)
            local color1 = RainbowColor(t)
            local color2 = RainbowColor(t + 2*math.pi/3)
            local color3 = RainbowColor(t + 4*math.pi/3)
            for _, tr in ipairs(trails) do
                if tr and tr.Parent then
                    tr.Color = ColorSequence.new({
                        ColorSequenceKeypoint.new(0, color1),
                        ColorSequenceKeypoint.new(0.5, color2),
                        ColorSequenceKeypoint.new(1, color3)
                    })
                else
                    for i = #trails, 1, -1 do
                        if not trails[i] or not trails[i].Parent then
                            table.remove(trails, i)
                        end
                    end
                end
            end
        end
        StartRainbowLoop()
    else
        if trailsCharConn then
            trailsCharConn:Disconnect()
            trailsCharConn = nil
        end
        local char = LocalPlayer.Character
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    for _, child in pairs(part:GetChildren()) do
                        if child.Name == "RainbowTrail" or child.Name == "TrailAttachment0" or child.Name == "TrailAttachment1" then
                            pcall(function() child:Destroy() end)
                        end
                    end
                end
            end
        end
        trails = {}
        rainbow_updaters["Trails"] = nil
        StopRainbowLoop()
    end
end)

toggles.JumpEffect = VisualSection:AddToggle("JumpEffect", {Title = "Jump effect", Default = false})
toggles.JumpEffect:OnChanged(function(val)
    if val then EffectManager:EnableEffect("Jump effect") else EffectManager:DisableEffect("Jump effect") end
end)

toggles.Particles = VisualSection:AddToggle("Particles", {Title = "Floating particles", Default = false})
toggles.Particles:OnChanged(function(val)
    if val then
        local function AddParticles(char)
            local head = char:WaitForChild("Head", 10)
            if not head then return end
            if particleEmitter then
                pcall(function() particleEmitter:Destroy() end)
            end
            particleEmitter = Instance.new("ParticleEmitter")
            particleEmitter.Parent = head
            particleEmitter.Size = NumberSequence.new(0.5)
            particleEmitter.Transparency = NumberSequence.new(0.5)
            particleEmitter.Lifetime = NumberRange.new(2)
            particleEmitter.Rate = 20
            particleEmitter.Speed = NumberRange.new(2)
            particleEmitter.VelocitySpread = 180
            particleEmitter.Rotation = NumberRange.new(0, 360)
            particleEmitter.Enabled = true
        end
        
        local char = LocalPlayer.Character
        if char then
            AddParticles(char)
        end
        
        if not particlesCharConn then
            particlesCharConn = LocalPlayer.CharacterAdded:Connect(function(newChar)
                if toggles.Particles.Value then
                    task.wait(1)
                    AddParticles(newChar)
                end
            end)
        end
        
        rainbow_updaters["Particles"] = function(t)
            local color1 = RainbowColor(t)
            local color2 = RainbowColor(t + 2*math.pi/3)
            local color3 = RainbowColor(t + 4*math.pi/3)
            if particleEmitter and particleEmitter.Parent then
                particleEmitter.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, color1),
                    ColorSequenceKeypoint.new(0.5, color2),
                    ColorSequenceKeypoint.new(1, color3)
                })
            end
        end
        StartRainbowLoop()
    else
        if particlesCharConn then
            particlesCharConn:Disconnect()
            particlesCharConn = nil
        end
        if particleEmitter then
            pcall(function() particleEmitter:Destroy() end)
            particleEmitter = nil
        end
        rainbow_updaters["Particles"] = nil
        StopRainbowLoop()
    end
end)

toggles.NeonGlow = VisualSection:AddToggle("NeonGlow", {Title = "Neon glow", Default = false})
toggles.NeonGlow:OnChanged(function(val)
    if val then
        local function AddNeonGlow(newChar)
            task.wait(1)
            VisualEffects:NeonGlow()
        end
        local char = LocalPlayer.Character
        if char then
            VisualEffects:NeonGlow()
        end
        if not neonGlowConn then
            neonGlowConn = LocalPlayer.CharacterAdded:Connect(AddNeonGlow)
        end
    else
        if neonGlowConn then
            neonGlowConn:Disconnect()
            neonGlowConn = nil
        end
        VisualEffects:ClearEffectByName("NeonGlow")
        rainbow_updaters["NeonGlow"] = nil
        StopRainbowLoop()
    end
end)

toggles.StarTrail = VisualSection:AddToggle("StarTrail", {Title = "Star trail", Default = false})
toggles.StarTrail:OnChanged(function(val)
    if val then
        local function AddStarTrail(newChar)
            task.wait(1)
            VisualEffects:StarTrail()
        end
        local char = LocalPlayer.Character
        if char then
            VisualEffects:StarTrail()
        end
        if not starTrailConn then
            starTrailConn = LocalPlayer.CharacterAdded:Connect(AddStarTrail)
        end
    else
        if starTrailConn then
            starTrailConn:Disconnect()
            starTrailConn = nil
        end
        VisualEffects:ClearEffectByName("StarTrail")
        if starTrailEmitter then
            pcall(function() starTrailEmitter:Destroy() end)
            starTrailEmitter = nil
        end
        rainbow_updaters["StarTrail"] = nil
        StopRainbowLoop()
    end
end)

toggles.FireAura = VisualSection:AddToggle("FireAura", {Title = "Fire aura", Default = false})
toggles.FireAura:OnChanged(function(val)
    if val then
        local function AddFireAura(newChar)
            task.wait(1)
            VisualEffects:FireAura()
        end
        local char = LocalPlayer.Character
        if char then
            VisualEffects:FireAura()
        end
        if not fireAuraConn then
            fireAuraConn = LocalPlayer.CharacterAdded:Connect(AddFireAura)
        end
    else
        if fireAuraConn then
            fireAuraConn:Disconnect()
            fireAuraConn = nil
        end
        VisualEffects:ClearEffectByName("FireAura")
    end
end)

toggles.SmokeTrail = VisualSection:AddToggle("SmokeTrail", {Title = "Smoke trail", Default = false})
toggles.SmokeTrail:OnChanged(function(val)
    if val then
        local function AddSmokeTrail(newChar)
            task.wait(1)
            VisualEffects:SmokeTrail()
        end
        local char = LocalPlayer.Character
        if char then
            VisualEffects:SmokeTrail()
        end
        if not smokeTrailConn then
            smokeTrailConn = LocalPlayer.CharacterAdded:Connect(AddSmokeTrail)
        end
    else
        if smokeTrailConn then
            smokeTrailConn:Disconnect()
            smokeTrailConn = nil
        end
        VisualEffects:ClearEffectByName("SmokeTrail")
    end
end)

toggles.SparkleBody = VisualSection:AddToggle("SparkleBody", {Title = "Body sparkles", Default = false})
toggles.SparkleBody:OnChanged(function(val)
    if val then
        local function AddSparkleBody(newChar)
            task.wait(1)
            VisualEffects:SparkleBody()
        end
        local char = LocalPlayer.Character
        if char then
            VisualEffects:SparkleBody()
        end
        if not sparkleBodyConn then
            sparkleBodyConn = LocalPlayer.CharacterAdded:Connect(AddSparkleBody)
        end
    else
        if sparkleBodyConn then
            sparkleBodyConn:Disconnect()
            sparkleBodyConn = nil
        end
        VisualEffects:ClearEffectByName("BodySparkles")
    end
end)

toggles.ColorShift = VisualSection:AddToggle("ColorShift", {Title = "Color shift", Default = false})
toggles.ColorShift:OnChanged(function(val)
    if val then
        local function AddColorShift(newChar)
            task.wait(1)
            VisualEffects:ColorShift()
        end
        local char = LocalPlayer.Character
        if char then
            VisualEffects:ColorShift()
        end
        if not colorShiftConn then
            colorShiftConn = LocalPlayer.CharacterAdded:Connect(AddColorShift)
        end
    else
        if colorShiftConn then
            colorShiftConn:Disconnect()
            colorShiftConn = nil
        end
        VisualEffects:ClearEffectByName("ColorShift")
    end
end)

-- Clear button
ClearSection:AddButton({
    Title = "Clear",
    Description = "Clear all visuals",
    Callback = function()
        EffectManager:ClearVisual()
        for name, toggle in pairs(toggles) do
            if name ~= "Speed" and name ~= "Jump" and name ~= "InfiniteJump" and name ~= "Noclip" and name ~= "Fly" and name ~= "HighlightESP" and name ~= "NameESP" and name ~= "DistanceESP" and name ~= "Aimbot" and name ~= "Spinbot" and name ~= "TeamCheck" and name ~= "WallCheck" then
                toggle:SetValue(false)
            end
        end
    end
})

-- Player modification toggles and sliders
toggles.Speed = PlayerSection:AddToggle("Speed", {Title = "Speed", Default = false})
toggles.Speed:OnChanged(function(val)
    if val then
        if not speedConnection then
            speedConnection = RunService.Heartbeat:Connect(function()
                local char = LocalPlayer.Character
                local humanoid = char and char:FindFirstChild("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = CurrentWalkSpeed
                end
            end)
        end
    else
        if speedConnection then
            pcall(function() speedConnection:Disconnect() end)
            speedConnection = nil
        end
        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = OriginalWalkSpeed
        end
    end
end)

PlayerSection:AddSlider("SpeedSlider", {
    Title = "Speed changer",
    Description = "Set walk speed (16-100)",
    Default = 16,
    Min = 16,
    Max = 100,
    Rounding = 0,
    Callback = function(val)
        CurrentWalkSpeed = val
    end
})

toggles.Jump = PlayerSection:AddToggle("Jump", {Title = "Jump", Default = false})
toggles.Jump:OnChanged(function(val)
    if val then
        if not jumpConnection then
            jumpConnection = RunService.Heartbeat:Connect(function()
                local char = LocalPlayer.Character
                local humanoid = char and char:FindFirstChild("Humanoid")
                if humanoid then
                    if humanoid.UseJumpPower then
                        humanoid.JumpPower = CurrentJumpPower
                    else
                        humanoid.JumpHeight = CurrentJumpPower / 7
                    end
                end
            end)
        end
    else
        if jumpConnection then
            pcall(function() jumpConnection:Disconnect() end)
            jumpConnection = nil
        end
        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChild("Humanoid")
        if humanoid then
            if humanoid.UseJumpPower then
                humanoid.JumpPower = OriginalJumpPower
            else
                humanoid.JumpHeight = OriginalJumpHeight
            end
        end
    end
end)

PlayerSection:AddSlider("JumpPowerSlider", {
    Title = "Jump Power",
    Description = "Set jump power (50-200)",
    Default = 50,
    Min = 50,
    Max = 200,
    Rounding = 0,
    Callback = function(val)
        CurrentJumpPower = val
        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChild("Humanoid")
        if humanoid and toggles.Jump.Value then
            if humanoid.UseJumpPower then
                humanoid.JumpPower = CurrentJumpPower
            else
                humanoid.JumpHeight = CurrentJumpPower / 7
            end
        end
    end
})

toggles.InfiniteJump = PlayerSection:AddToggle("InfiniteJump", {Title = "Infinite Jump", Default = false})
toggles.InfiniteJump:OnChanged(function(val)
    InfiniteJumpEnabled = val
    if val then
        if not infiniteJumpConnection then
            infiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
                if InfiniteJumpEnabled then
                    local char = LocalPlayer.Character
                    local humanoid = char and char:FindFirstChild("Humanoid")
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end)
        end
    else
        if infiniteJumpConnection then
            pcall(function() infiniteJumpConnection:Disconnect() end)
            infiniteJumpConnection = nil
        end
    end
end)

toggles.Noclip = PlayerSection:AddToggle("Noclip", {Title = "Noclip", Default = false})
toggles.Noclip:OnChanged(function(val)
    NoclipEnabled = val
    if val then
        if not noclipConnection then
            noclipConnection = RunService.Stepped:Connect(function()
                local char = LocalPlayer.Character
                if char and NoclipEnabled then
                    for _, part in pairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if noclipConnection then
            pcall(function() noclipConnection:Disconnect() end)
            noclipConnection = nil
        end
        local char = LocalPlayer.Character
        if char then
            for _, part in pairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end)

toggles.Fly = PlayerSection:AddToggle("Fly", {Title = "Fly", Default = false})
toggles.Fly:OnChanged(function(val)
    FlyEnabled = val
    if val then
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if root then
            if flyBodyVelocity then
                pcall(function() flyBodyVelocity:Destroy() end)
            end
            flyBodyVelocity = Instance.new("BodyVelocity")
            flyBodyVelocity.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
            flyBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            flyBodyVelocity.Parent = root

            if not flyConnection then
                flyConnection = RunService.RenderStepped:Connect(function()
                    local camera = Workspace.CurrentCamera
                    local moveDirection = Vector3.new()
                    if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                        moveDirection = moveDirection + camera.CFrame.LookVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                        moveDirection = moveDirection - camera.CFrame.LookVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                        moveDirection = moveDirection + camera.CFrame.RightVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                        moveDirection = moveDirection - camera.CFrame.RightVector
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        moveDirection = moveDirection + Vector3.new(0, 1, 0)
                    end
                    if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                        moveDirection = moveDirection - Vector3.new(0, 1, 0)
                    end
                    if FlyEnabled and flyBodyVelocity and flyBodyVelocity.Parent then
                        flyBodyVelocity.Velocity = moveDirection.Unit * FlySpeed
                    else
                        if flyConnection then
                            flyConnection:Disconnect()
                            flyConnection = nil
                        end
                        if flyBodyVelocity then
                            pcall(function() flyBodyVelocity:Destroy() end)
                            flyBodyVelocity = nil
                        end
                    end
                end)
            end
        end
    else
        if flyConnection then
            pcall(function() flyConnection:Disconnect() end)
            flyConnection = nil
        end
        if flyBodyVelocity then
            pcall(function() flyBodyVelocity:Destroy() end)
            flyBodyVelocity = nil
        end
    end
end)

PlayerSection:AddSlider("FlySpeed", {
    Title = "Fly speed",
    Description = "Set fly speed (50-200)",
    Default = 50,
    Min = 50,
    Max = 200,
    Rounding = 0,
    Callback = function(val)
        FlySpeed = val
    end
})

-- Autofarm toggles
local AutofarmSection = Tabs.Utilities:AddSection("Autofarm")

toggles.AutoFarm = AutofarmSection:AddToggle("AutoFarm", {Title = "Auto farm", Default = false})
toggles.AutoFarm:OnChanged(function(val)
    runningAutofarm = val
    if val then
        task.spawn(AutofarmLoop)
    end
end)

toggles.AutoUpgrade = AutofarmSection:AddToggle("AutoUpgrade", {Title = "Auto upgrade", Default = false})
toggles.AutoUpgrade:OnChanged(function(val)
    runningUpgrade = val
    if val then
        task.spawn(AutoUpgradeLoop)
    end
end)

toggles.AutoNextRagdoll = AutofarmSection:AddToggle("AutoNextRagdoll", {Title = "Auto next ragdoll", Default = false})
toggles.AutoNextRagdoll:OnChanged(function(val)
    runningNextRagdoll = val
    if val then
        task.spawn(AutoNextRagdollLoop)
    end
end)

toggles.AutoRefine = AutofarmSection:AddToggle("AutoRefine", {Title = "Auto refine", Default = false})
toggles.AutoRefine:OnChanged(function(val)
    runningRefine = val
    if val then
        task.spawn(AutoRefineLoop)
    end
end)

-- Cleanup on player removal
Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        CleanupAll()
    end
end)

-- Initialize UI
Window:SelectTab(1)
SaveManager:LoadAutoloadConfig()
